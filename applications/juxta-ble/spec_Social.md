# Social Data File Format Specification

## Overview
This document describes the format of social interaction data files generated by JUXTA devices operating in NORMAL mode. These files contain minute-by-minute records of BLE device scanning, motion detection, and environmental monitoring data.

## File Structure
- **Filename format**: `YYMMDD` (e.g., `250120` for January 20, 2025)
- **File content**: Sequential minute-by-minute records
- **Record types**: Device scan records and system event records

## Record Types

### Device Scan Records (0x00-0x80)
Records containing BLE scan results, motion data, and environmental sensors for each minute.

**Record Type Encoding**:
- **0x00**: No devices detected this minute
- **0x01-0x80**: Number of devices detected (1-128 devices)

### System Event Records (0xF1-0xF5)
Simple records marking system events and state changes.

**Event Types**:
- **0xF1**: System boot/restart
- **0xF2**: BLE connection established  
- **0xF3**: Settings changed
- **0xF5**: System error

## Device Scan Record Format

### Fixed Header (6 bytes)
All device scan records start with a 6-byte header:

```
Byte 0-1:   Minute of day (16-bit big-endian, 0-1439)
Byte 2:     Device count (8-bit, 0-128, also serves as record type)
Byte 3:     Motion count (8-bit, motion events detected this minute)
Byte 4:     Battery level (8-bit, 0-100 percentage)
Byte 5:     Temperature (8-bit signed, degrees Celsius)
```

### Variable Data (2 × device_count bytes)
Following the header, device-specific data for each detected device:

```
For each device (i = 0 to device_count-1):
  Byte (6 + i):                    MAC index (8-bit, index into global MAC table)
  Byte (6 + device_count + i):     RSSI value (8-bit signed, dBm)
```

## MAC Address Resolution

Device scan records reference a global MAC address table using indices rather than storing full MAC addresses.

### MAC Index Table (MACIDX)
- **Location**: Separate data structure in FRAM
- **Format**: 3-byte packed MAC addresses + metadata
- **Access**: Via special "MACIDX" file transfer
- **Purpose**: Space-efficient storage of unique device identifiers

### MAC Address Format
- **Full MAC**: 6-byte Bluetooth address (e.g., `AB:CD:EF:12:34:56`)
- **Packed format**: Last 3 bytes only (e.g., `0x123456`)
- **Device naming**: `JX_123456` or `JXGA_1234` (gateway)

## Decoding Examples

### Device Scan Record (3 devices detected)
```
05A003020A0F0001020A0B0C
```

#### Header Decoding
```
Bytes 0-1:   05 A0        → Minute: 0x05A0 = 1440 minutes = 24:00 (end of day)
Byte 2:      03           → Device count: 3 devices detected
Byte 3:      02           → Motion count: 2 motion events this minute
Byte 4:      0A           → Battery level: 10% (low battery warning)
Byte 5:      0F           → Temperature: 15°C
```

#### Device Data
```
Bytes 6-8:   00 01 02     → MAC indices: [0, 1, 2] (references to MAC table)
Bytes 9-11:  0A 0B 0C     → RSSI values: [-10, -11, -12] dBm (signed)
```

### No Activity Record
```
02D000050A0F
```

#### Decoding
```
Bytes 0-1:   02 D0        → Minute: 0x02D0 = 720 minutes = 12:00 noon
Byte 2:      00           → Device count: 0 devices (no activity)
Byte 3:      05           → Motion count: 5 motion events (device was active)
Byte 4:      0A           → Battery level: 10%
Byte 5:      0F           → Temperature: 15°C
```

### System Boot Record
```
000000F1
```

#### Decoding
```
Bytes 0-1:   00 00        → Minute: 0 (midnight)
Byte 2:      F1           → Record type: System boot
```

## Data Interpretation

### Timing
- **Minute of day**: 0-1439 (0 = 00:00, 1439 = 23:59)
- **Time calculation**: `hours = minute / 60`, `minutes = minute % 60`
- **Absolute time**: Requires Unix timestamp from file metadata or BLE sync

### Motion Detection
- **Motion count**: Number of motion events detected in the current minute
- **Source**: LIS2DH accelerometer-based motion detection
- **Threshold**: Configurable motion sensitivity

### Battery Monitoring
- **Range**: 0-100 (percentage)
- **Frequency**: Updated every minute
- **Low battery**: Typically < 20% triggers warnings

### Temperature
- **Range**: -128 to +127°C (signed 8-bit)
- **Source**: LIS2DH internal temperature sensor
- **Accuracy**: ±2°C typical

### RSSI Values
- **Range**: -128 to +127 dBm (signed 8-bit)
- **Interpretation**: Higher values = stronger signal = closer proximity
- **Typical range**: -30 dBm (very close) to -100 dBm (far)

## Python Decoding Example

```python
import struct

def decode_social_record(file_data, offset=0):
    """
    Decode a single social interaction record
    
    Args:
        file_data: Raw file data (bytes)
        offset: Starting offset in file
        
    Returns:
        dict: Decoded record information
    """
    # Need at least 6 bytes for header
    if len(file_data) < offset + 6:
        return None
        
    header = file_data[offset:offset + 6]
    
    # Unpack header using big-endian format
    minute, device_count, motion_count, battery_level, temperature = struct.unpack('>HBBBB', header)
    
    # Convert temperature from unsigned to signed
    if temperature > 127:
        temperature = temperature - 256
    
    # Calculate record size
    record_size = 6 + (2 * device_count)
    if len(file_data) < offset + record_size:
        return None
    
    # Decode device data if present
    devices = []
    if device_count > 0:
        mac_indices = file_data[offset + 6:offset + 6 + device_count]
        rssi_data = file_data[offset + 6 + device_count:offset + record_size]
        
        for i in range(device_count):
            rssi = rssi_data[i]
            # Convert RSSI from unsigned to signed
            if rssi > 127:
                rssi = rssi - 256
                
            devices.append({
                'mac_index': mac_indices[i],
                'rssi_dbm': rssi
            })
    
    # Determine record type
    if device_count >= 0xF1:
        record_type = 'system_event'
        event_name = {
            0xF1: 'boot',
            0xF2: 'connected', 
            0xF3: 'settings',
            0xF5: 'error'
        }.get(device_count, 'unknown')
    elif device_count == 0:
        record_type = 'no_activity'
        event_name = None
    else:
        record_type = 'device_scan'
        event_name = None
    
    # Convert minute to human time
    hours = minute // 60
    mins = minute % 60
    time_str = f"{hours:02d}:{mins:02d}"
    
    return {
        'record_type': record_type,
        'event_name': event_name,
        'minute_of_day': minute,
        'time': time_str,
        'device_count': device_count if record_type == 'device_scan' else 0,
        'motion_count': motion_count,
        'battery_level': battery_level,
        'temperature_c': temperature,
        'devices': devices,
        'record_size': record_size,
        'next_offset': offset + record_size
    }

def decode_social_file(filename, mac_table=None):
    """
    Decode entire social interaction file
    
    Args:
        filename: Path to social data file
        mac_table: Optional MAC address lookup table
        
    Returns:
        list: List of decoded records
    """
    with open(filename, 'rb') as f:
        file_data = f.read()
    
    records = []
    offset = 0
    
    while offset < len(file_data) - 6:  # Need at least 6 bytes for header
        try:
            record = decode_social_record(file_data, offset)
            if record is None:
                break
            records.append(record)
            offset = record['next_offset']
        except (struct.error, IndexError):
            break  # End of file or corrupted data
    
    return records

def resolve_mac_addresses(records, mac_table):
    """
    Resolve MAC indices to actual MAC addresses
    
    Args:
        records: Decoded social records
        mac_table: MAC address lookup table (index -> MAC)
        
    Returns:
        list: Records with resolved MAC addresses
    """
    for record in records:
        if record['record_type'] == 'device_scan':
            for device in record['devices']:
                mac_index = device['mac_index']
                if mac_index in mac_table:
                    device['mac_address'] = mac_table[mac_index]
                else:
                    device['mac_address'] = f"UNKNOWN_{mac_index}"
    
    return records
```

## Data Architecture Summary

### Record Structure Overview
1. **Device Scan Records**: 6-byte header + (2 × device_count) bytes
2. **System Event Records**: 3-byte simple records
3. **MAC Resolution**: Via separate MACIDX table

### Social Interaction Analysis
- **Proximity detection**: RSSI values indicate distance/signal strength
- **Temporal patterns**: Minute-by-minute interaction logging
- **Motion correlation**: Motion events aligned with social encounters
- **Environmental context**: Battery and temperature data

### File Organization
- **One file per day**: All social data consolidated by date
- **Sequential records**: No delimiters, records stored back-to-back
- **Variable length**: Record size depends on device count
- **Efficient storage**: MAC indices reduce storage overhead

## Notes
- **Endianness**: All multi-byte values stored in big-endian format
- **Minute resolution**: All events logged to the nearest minute
- **MAC compression**: 6-byte MACs compressed to 3-byte indices
- **RSSI range**: -128 to +127 dBm (signed 8-bit values)
- **Motion integration**: LIS2DH accelerometer motion events per minute
- **Battery monitoring**: Percentage-based battery level (0-100)
- **Temperature**: LIS2DH internal temperature sensor readings
- **File transfer**: Data sent as hex strings via BLE with EOF marker
